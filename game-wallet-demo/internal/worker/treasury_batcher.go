package worker

import (
	"context"
	"fmt"
	"game-wallet-demo/config"
	"game-wallet-demo/prisma/db"
	"sync"
	"time"
)

type TreasuryTask struct {
	Amount    int
	JournalID string
	Desc      string
}

type TreasuryBatcher struct {
	client        *db.PrismaClient
	queue         chan TreasuryTask
	batchSize     int
	flushInterval time.Duration
	wg            sync.WaitGroup
	mu            sync.Mutex
}

var GlobalBatcher *TreasuryBatcher

func InitTreasuryBatcher(client *db.PrismaClient) {
	GlobalBatcher = &TreasuryBatcher{
		client:        client,
		queue:         make(chan TreasuryTask, 10000),
		batchSize:     100,
		flushInterval: 500 * time.Millisecond,
	}
	go GlobalBatcher.Start()
	fmt.Println("⚙️  Treasury Async Batcher Started")
}

func (b *TreasuryBatcher) Submit(task TreasuryTask) {
	select {
	case b.queue <- task:
	default:
		fmt.Println("⚠️ Treasury Queue Full! Dropping metric")
	}
}

func (b *TreasuryBatcher) Start() {
	buffer := make([]TreasuryTask, 0, b.batchSize)
	ticker := time.NewTicker(b.flushInterval)

	for {
		select {
		case task := <-b.queue:
			buffer = append(buffer, task)
			if len(buffer) >= b.batchSize {
				b.Flush(buffer)
				buffer = buffer[:0]
			}
		case <-ticker.C:
			if len(buffer) > 0 {
				b.Flush(buffer)
				buffer = buffer[:0]
			}
		}
	}
}

// Flush executes the Bulk Insert and Single Balance Update
func (b *TreasuryBatcher) Flush(tasks []TreasuryTask) {
	if len(tasks) == 0 {
		return
	}

	ctx := context.Background()
	totalAmount := 0

	// 1. Prepare a slice to hold all transaction operations
	// db.PrismaTransaction is an interface generated by your client
	var ops []db.PrismaTransaction

	for _, task := range tasks {
		totalAmount += task.Amount

		// 2. Create Ledger Entry Operation
		// Notice .Tx() at the end instead of .Exec(ctx)
		op := b.client.LedgerEntry.CreateOne(
			db.LedgerEntry.Amount.Set(task.Amount),
			db.LedgerEntry.Account.Link(db.Account.ID.Equals(config.TreasuryID)),
			db.LedgerEntry.Journal.Link(db.Journal.ID.Equals(task.JournalID)),
		).Tx()

		ops = append(ops, op)
	}

	// 3. Create Balance Update Operation
	// Again, use .Tx() to prepare it without executing
	opUpdate := b.client.Account.FindUnique(
		db.Account.ID.Equals(config.TreasuryID),
	).Update(
		db.Account.CachedBalance.Increment(totalAmount),
	).Tx()

	ops = append(ops, opUpdate)

	// 4. Execute ALL operations in a single atomic transaction
	if err := b.client.Prisma.Transaction(ops...).Exec(ctx); err != nil {
		fmt.Printf("❌ Batch Flush Failed: %v\n", err)
	} else {
		fmt.Printf("✅ Flushed %d items to Treasury\n", len(tasks))
    }
}